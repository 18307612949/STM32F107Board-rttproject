
#include <stdint.h>  

/*
1. 变量说明 
 RevBuf 为串口接收缓冲区，如果接收了一个报文则解析， RevLen 为长度 RevBuf[0] 接收数据第一个字节，
 RevBuf[0] 为T188协议帧开始标志。根据功能号做出响应解析接收到的数据UartSend(SendBuf)。
串口接收一帧后进行解析 Tbyte = 11* 1/bps 如果9600bps, 则Tbyte = 1.146ms

2. T188协议说明
1)前导字符 2~4个 0xFE 
2)线路空闲时间 , 即帧间 的间隔30ms
3)字节间停顿时间 1Tbyte 最长2400bps, 4.6ms
4)采集器 -> 表计
读表计控制码：0x01 数据长度 0x03 数据标识 0x901F 序列号 0x00
帧开始 表计类型 表计地址 控制码 长度 数据标识 序列号 校验和 帧结束
0x68   0x10      A0-A6   0x01   0x03  0x901F   0x00   CS     0x16
  表计 -> 采集器
表计回复控制码：0x81 数据长度 0x09 数据标识 0x901F 序列号 0x00
帧开始 表计类型 表计地址 控制码 长度 数据标识 序列号 累计流量 状态0 状态1 校验和 帧结束
0x68   0x10      A0-A6   0x81  0x09  0x901F   0x00   D0-D3    0x00  0xFF   CS     0x16

3. 程序运行步骤
1)串口接收一帧数据 RevBuf，长度 RevLen
2)调用T188Handle处理接收的数据
3)如果控制码为0x01，则填充发送数据帧 SendBuf，长度 SendLen
4)调用函数 UartSend(SendBuf,SendLen) 发送数据

4. 移植步骤
1)在其它部分填充 data 数据，为当前表计的读数
2)定时检查串口接收数据，按照帧间的间隔30ms, 字节间的间隔4.6ms，收取一帧数据后，调用T188Handle
3)填充函数 UartSend(SendBuf,SendLen) ，发送一帧数据

5. 测试数据
采集器发送数据：68 10 00 00 00 00 00 00 01 01 03 90 1F 00 2C 16
表计回复：      68 10 00 00 00 00 00 00 01 81 09 90 1F 00 78 56 34 12 CS 16
*/
/*定义T188表计地址*/
#define A0 0x00
#define A1 0x00
#define A2 0x00
#define A3 0x00
#define A4 0x00
#define A5 0x00
#define A6 0x01
/*定义表内的数据计数*/
int data = 12345678;
/*定义串口发送数据函数*/
void UartSend(unsigned char* SendBuf, uint32_t SendLen)
{
  extern void Usart2PutChar(uint8_t ch);
  while(SendLen--)
    Usart2PutChar(*SendBuf++);
}

/*******************************************************************************
* Function Name  : Dec2BCD
* Description    : 十进制转BCD码 
* Input          : int Dec                      待转换的十进制数据 
					int length                   BCD码数据长度 
* Output         : unsigned char *Bcd           转换后的BCD码
* Return         : 0  success 
*******************************************************************************/
static int Dec2BCD(int Dec, unsigned char *Bcd, int length) 
{ 
     int i; 
     int temp; 
     for(i=length-1; i>=0; i--) 
     { 
         temp = Dec%100; 
         Bcd[i] = ((temp/10)<<4) + ((temp%10) & 0x0F); 
         Dec /= 100; 
     } 
     return 0; 
} 

/*******************************************************************************
* Function Name  : CalSum
* Description    : 和校验函数，生成和字符
* Input          : Message原码 DataLenth 原码长度 
* Output         : 
* Return         : 输出和字符
*******************************************************************************/
static uint8_t CalSum(uint8_t *rxbuffer,uint16_t len)    
{    
  uint8_t sum;
  sum = 0;
  for(int i=0;i<len;i++)
  {
    sum = sum + rxbuffer[i];//累加和
  }
  return sum;  
}  

/*******************************************************************************
* Function Name  : T188Handle
* Description    : T188从机处理函数  ，在主函数中收到一帧数据后被调用
* Input          : 
* Output         : 
* Return         : 0 无错误  1帧起始错  2校验错 3读数据命令错
*******************************************************************************/
uint8_t T188Handle(unsigned char* RevBuf,uint32_t RevLen)
{
	uint32_t i;
	unsigned char BcdData[4]={0x00};
        unsigned char SendBuf[64] = {0x00};
	/*删除前导字符 0xFE */
	while(RevBuf[0] == 0xFE)
	{
		RevLen = RevLen - 1;
		for(i=0 ;i<RevLen ; i++)
		{
			RevBuf[i] = RevBuf[i+1];
		}
	}
	/*判断帧开始标志 0x68 */
	if(RevBuf[0] == 0x68)
	{
	
	}
	else
	{
		return 1;
	}
	/*判断读数据标志 0x01 */
	if(RevBuf[9] == 0x01)
	{
	
	}
	else
	{
		return 3;
	}
	/*判断校验位是否正确 */
	if(RevBuf[14] == CalSum(RevBuf, 14))
	{
	
	}
	else
	{
		return 2;
	}
	
	/*填充发送字节
	帧开始 表计类型 表计地址 控制码 长度 数据标识 序列号 累计流量 状态0 状态1 校验和 帧结束
	0x68   0x10      A0-A6   0x81  0x09  0x901F   0x00   D0-D3    0x00  0xFF   CRC    0x16 */
	{
		SendBuf[0] = 0x68;	
		SendBuf[1] = 0x10;//类型	
		SendBuf[2] = A0;//地址	
		SendBuf[3] = A1;	
		SendBuf[4] = A2;	
		SendBuf[5] = A3;	
		SendBuf[6] = A4;	
		SendBuf[7] = A5;	
		SendBuf[8] = A6;	
		SendBuf[9] = 0x81;	//控制码
		SendBuf[10] = 0x09;	//长度
		SendBuf[11] = 0x90;	//数据标识
		SendBuf[12] = 0x1F;	
		SendBuf[13] = 0x00;	//序号
		
		/*将数据转换成BCD码*/
		Dec2BCD(data, BcdData, 4);
		
		SendBuf[14] = BcdData[3];	//流量 低位在前
		SendBuf[15] = BcdData[2];	
		SendBuf[16] = BcdData[1];	
		SendBuf[17] = BcdData[0];	
		
		SendBuf[18] = 0x00;	//状态0
		SendBuf[19] = 0xFF;	//状态1
		SendBuf[20] = CalSum(SendBuf,20);	//CRC
		SendBuf[21] = 0x68;	
	}
	
	/*发送数据*/
	UartSend(SendBuf, 22);
        return 0;
}


////////////////////////////////////////////////////////////////////////////////////
//以下Modbus从机
/*
3. Modbus协议说明
1)线路空闲时间 , 即帧间 的间隔 t3.5 > 1.75ms
2)字节间停顿时间 t1.5 > 750us
3)采集器 -> 表计
读表计控制码：0x03  
 表计地址 功能码  起始地址   数据长度  校验和 帧结束
      XX   0x03  0x00 0x00  0x00 0x02  0xC4 0x0B
  表计 -> 采集器
 表计地址 功能码 长度     数据0    数据1    校验和 
    XX     0x03  0x04  0x00 0x01 0x00 0x00 0xAB 0xF3

3. 程序运行步骤
1)串口接收一帧数据 RevBuf，长度 RevLen
2)调用ModbusHandle处理接收的数据
3)如果控制码为0x03，则填充发送数据帧 SendBuf，长度 SendLen
4)调用函数 UartSend(SendBuf,SendLen) 发送数据

4. 移植步骤
1)在其它部分填充 data 数据，为当前表计的读数
2)定时检查串口接收数据，按照帧间的间隔30ms, 字节间的间隔4.6ms，收取一帧数据后，调用调用ModbusHandle处理接收的数据
3)填充函数 UartSend(SendBuf,SendLen) ，发送一帧数据

5. 测试数据
采集器发送数据：01 03 00 01 00 06 94 08
表计回复：      01 03 0C CE 30 CE 40 CE 50 CE 60 7E 20 CE 80 D2 31
*/
/*定义Modbus表计地址*/
#define ModbusAddr 0x01
/*定义表内的数据计数*/
uint8_t modbusdata[16] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
                          0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };

/*******************************************************************************
* Function Name  : CalCRC
* Description    : CRC校验函数，生成CRC字符
* Input          : Message原码 DataLenth 原码长度 
* Output         : CRCAddr 输出计算的CRC地址
* Return         : None
*******************************************************************************/
void CalCRC(uint8_t *Message, uint16_t DataLenth, uint16_t *CRCAddr)    
{    
  /* CRC 高位字节值表 */    
    uint8_t CRC_TableHigh[256] = {  
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,    
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,    
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,    
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,    
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,    
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,    
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,    
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,    
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,    
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40  
    };    
      
    uint8_t CRC_TableLow[256] = {  
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,    
    0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,    
    0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,    
    0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,    
    0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,    
    0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,    
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,    
    0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,    
    0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,    
    0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,    
    0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,    
    0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,    
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,    
    0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,    
    0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,    
    0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,    
    0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,    
    0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,    
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,    
    0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,    
    0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,    
    0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,    
    0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,    
    0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,    
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,    
    0x43, 0x83, 0x41, 0x81, 0x80, 0x40  
    };  
      
    uint8_t CRC_InitHigh = 0xFF ; /* 高CRC字节初始化 */    
    uint8_t CRC_InitLow = 0xFF ; /* 低CRC 字节初始化 */    
    uint8_t CRC_Index = 0x00; /* CRC循环中的索引 */    
      
    while(DataLenth--) /* 传输消息缓冲区 */    
    {    
        CRC_Index = CRC_InitHigh ^ *Message++ ; /* 计算CRC */    
        CRC_InitHigh = CRC_InitLow ^ CRC_TableHigh[CRC_Index] ;    
        CRC_InitLow = CRC_TableLow[CRC_Index] ;    
    } 
    *CRCAddr = ((uint16_t) CRC_InitLow << 8 | CRC_InitHigh);
}  

/*******************************************************************************
* Function Name  : ModbusHandle
* Description    : Modbus从机处理函数  ，在主函数中收到一帧数据后被调用
* Input          : 
* Output         : 
* Return         : 0 无错误  1帧地址错  2校验错 3读数据命令错
*******************************************************************************/
uint8_t ModbusHandle(unsigned char* RevBuf,uint32_t RevLen)
{
	uint32_t i;
        uint32_t len;
        uint8_t SendBuf[64] = {0x00};
        uint16_t  CRC16[1];
      
        
	/*判断帧地址 */
	if(RevBuf[0] == ModbusAddr)
	{
	
	}
	else
	{
		return 1;
	}
        
        /*CRC计算*/    
        CalCRC(RevBuf,RevLen-2,CRC16);
        if(*(uint16_t *)(CRC16)!=*(uint16_t *)(RevBuf+RevLen-2))
        {
          return 2; /*("校验错误");*/
        }

	/*判断读数据功能码 0x03 */
	if(RevBuf[1] == 0x03)
	{
	
	}
	else
	{
		return 3;
	}
	
        len = RevBuf[4]*256 + RevBuf[5];
        len = len * 2;  //字节数要*2
	/*填充发送字节
	表计地址 功能码 长度高 长度低  数据1 数据2 数据3 数据4 ... CRC高 CRC低
	 */
	{
          SendBuf[0] = ModbusAddr;	
          SendBuf[1] = 0x03;//功能码	
          SendBuf[2] = len;//长度
          for(i=0; i<len; i++)
          {
            SendBuf[i+3] = modbusdata[i];
          }
          /*CRC计算*/    
          CalCRC(SendBuf,len+3,(uint16_t *)&SendBuf[len+3]);
	}
	
	/*发送数据*/
	UartSend(SendBuf, len+5);
        return 0;
}
